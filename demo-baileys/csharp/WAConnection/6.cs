/// This file was generated by C# converter tool
/// Any changes made to this file manually will be lost next time the file is regenerated.

using System.Linq;
using TypeScript.CSharp;
using Base = Bailey.WAConnection;

namespace Bailey
{
    public class WAConnection : Base
    {
        /// <summary>
        /// Send a message to the given ID (can be group, single, or broadcast)
        /// </summary>
        /// <param name = "id">
        /// the id to send to
        /// </param>
        /// <param name = "message">
        /// the message can be a buffer, plain string, location message, extended text message
        /// </param>
        /// <param name = "type">
        /// type of message
        /// </param>
        /// <param name = "options">
        /// Extra options
        /// </param>
        async public void sendMessage(string id, OrType<string, WATextMessage, WALocationMessage, WAContactMessage, WAContactsArrayMessage, WAGroupInviteMessage, WAMediaUpload, WAListMessage, WAButtonsMessage> message, MessageType type, MessageOptions options = new MessageOptions())
        {
            var waMessage = await this.prepareMessage(id, message, type, options);
            await this.relayWAMessage(waMessage, new Dictionary<string, bool>() { { "waitForAck", options.waitForAck != false } });
            return waMessage;
        }

        /// <summary>
        /// Send a list message
        /// </summary>
        /// <param name = "id">
        /// the id to send to
        /// </param>
        /// <param name = "button">
        /// the optional button text, title and description button
        /// </param>
        /// <param name = "rows">
        /// the rows of sections list message
        /// </param>
        async public void sendListMessage(string id, (string buttonText, string description, string title) button, dynamic rows = new dynamic())
        {
            var messageList = WAMessageProto.Message.fromObject(new Dictionary<string, dynamic>() { { "listMessage", WAMessageProto.ListMessage.fromObject((buttonText: button.buttonText, description: button.description, listType: 1, sections: new dynamic { (title: button.title, rows: (new dynamic { }).Spread(rows)) })) } });
            var waMessageList = await this.prepareMessageFromContent(id, messageList, new MessageOptions());
            await this.relayWAMessage(waMessageList, new Dictionary<string, bool>() { { "waitForAck", true } });
            return waMessageList;
        }

        /// <summary>
        /// Prepares a message for sending via sendWAMessage ()
        /// </summary>
        async public void prepareMessage(string id, OrType<string, WATextMessage, WALocationMessage, WAContactMessage, WAContactsArrayMessage, WAGroupInviteMessage, WAMediaUpload, WAListMessage, WAButtonsMessage> message, MessageType type, MessageOptions options = new MessageOptions())
        {
            var content = await this.prepareMessageContent(message, type, options);
            var preparedMessage = this.prepareMessageFromContent(id, content, options);
            return preparedMessage;
        }

        /// <summary>
        /// Toggles disappearing messages for the given chat
        /// </summary>
        /// <param name = "jid">
        /// the chat to toggle
        /// </param>
        /// <param name = "ephemeralExpiration">
        /// 0 to disable, enter any positive number to enable disappearing messages for the specified duration; 
        /// For the default see WA_DEFAULT_EPHEMERAL
        /// </param>
        async public void toggleDisappearingMessages(string jid, double ephemeralExpiration = 0, Dictionary<string, bool> opts = new Dictionary<string, bool>()
        {
            {
                "waitForAck",
                true
            }
        }

        )
        {
            if (isGroupID(jid))
            {
                var tag = this.generateMessageTag(true);
                await this.setQuery(new List<WANode> { new List<WANode> { "group", (id: tag, jid: jid, type: "prop", author: this.user.jid), new List<dynamic> { new List<dynamic> { "ephemeral", new Dictionary<string, dynamic>() { { "value", ephemeralExpiration.toString() } }, null } } } }, new WATag { WAMetric.group, WAFlag.other }, tag);
            }
            else
            {
                var message = this.prepareMessageFromContent(jid, this.prepareDisappearingMessageSettingContent(ephemeralExpiration), new MessageOptions());
                await this.relayWAMessage(message, opts);
            }
        }

        /// <summary>
        /// Prepares the message content
        /// </summary>
        async public void prepareMessageContent(OrType<string, WATextMessage, WALocationMessage, WAContactMessage, WAContactsArrayMessage, WAGroupInviteMessage, WAMediaUpload, WAListMessage, WAButtonsMessage> message, MessageType type, MessageOptions options)
        {
            WAMessageContent m = new WAMessageContent();
            switch (type)
            {
                case MessageType.text:
                case MessageType.extendedText:
                    if (TypeOf(message) == "string")
                        message = new Dictionary<string, OrType<string, WATextMessage, WALocationMessage, WAContactMessage, WAContactsArrayMessage, WAGroupInviteMessage, WAMediaUpload, WAListMessage, WAButtonsMessage>>()
                        {
                            {
                                "text",
                                message
                            }
                        }

                        as WATextMessage;
                    if (message.Contains("text"))
                    {
                        if (options.detectLinks != false && message.text.match(URL_REGEX))
                        {
                            try
                            {
                                message = await this.generateLinkPreview(message.text);
                            }
                            catch (Exception error)
                            {
                                this.logger.trace($"failed to generate link preview for message '{message.text}': {error}");
                            }
                        }

                        m.extendedTextMessage = WAMessageProto.ExtendedTextMessage.fromObject(message as dynamic);
                    }
                    else
                    {
                        throw new BaileysError("message needs to be a string or object with property 'text'", message);
                    }

                    break;
                case MessageType.location:
                case MessageType.liveLocation:
                    m.locationMessage = WAMessageProto.LocationMessage.fromObject(message as dynamic);
                    break;
                case MessageType.contact:
                    m.contactMessage = WAMessageProto.ContactMessage.fromObject(message as dynamic);
                    break;
                case MessageType.contactsArray:
                    m.contactsArrayMessage = WAMessageProto.ContactsArrayMessage.fromObject(message as dynamic);
                    break;
                case MessageType.groupInviteMessage:
                    m.groupInviteMessage = WAMessageProto.GroupInviteMessage.fromObject(message as dynamic);
                    break;
                case MessageType.listMessage:
                    m.listMessage = WAMessageProto.ListMessage.fromObject(message as dynamic);
                    break;
                case MessageType.buttonsMessage:
                    m.buttonsMessage = WAMessageProto.ButtonsMessage.fromObject(message as dynamic);
                    break;
                case MessageType.image:
                case MessageType.sticker:
                case MessageType.document:
                case MessageType.video:
                case MessageType.audio:
                    m = await this.prepareMessageMedia(message as Buffer, type, options);
                    break;
            }

            return WAMessageProto.Message.fromObject(m);
        }

        public void prepareDisappearingMessageSettingContent(double ephemeralExpiration = 0)
        {
            ephemeralExpiration = ephemeralExpiration || 0;
            WAMessageContent content = new WAMessageContent()
            {
                {
                    "ephemeralMessage",
                    new Dictionary<string, Dictionary<string, (dynamic type, dynamic ephemeralExpiration)>>()
                    {
                        {
                            "message",
                            new Dictionary<string, (dynamic type, dynamic ephemeralExpiration)>()
                            {
                                {
                                    "protocolMessage",
                                    (type: WAMessageProto.ProtocolMessage.ProtocolMessageType.EPHEMERAL_SETTING, ephemeralExpiration: ephemeralExpiration)
                                }
                            }
                        }
                    }
                }
            };
            return WAMessageProto.Message.fromObject(content);
        }

        /// <summary>
        /// Prepare a media message for sending
        /// </summary>
        async public void prepareMessageMedia(WAMediaUpload media, MessageType mediaType, MessageOptions options = new MessageOptions())
        {
            if (mediaType == MessageType.document && !options.mimetype)
            {
                throw new Error("mimetype required to send a document");
            }

            if (mediaType == MessageType.sticker && options.caption)
            {
                throw new Error("cannot send a caption with a sticker");
            }

            if (!(mediaType == MessageType.image || mediaType == MessageType.video) && options.viewOnce)
            {
                throw new Error($"cannot send a {mediaType} as a viewOnceMessage");
            }

            if (!options.mimetype)
            {
                options.mimetype = MimetypeMap[mediaType];
            }

            var isGIF = false;
            if (options.mimetype == Mimetype.gif)
            {
                isGIF = true;
                options.mimetype = MimetypeMap[MessageType.video];
            }

            var requiresDurationComputation = mediaType == MessageType.audio && !options.duration;
            var requiresThumbnailComputation = (mediaType == MessageType.image || mediaType == MessageType.video) && !(options.Contains("thumbnail"));
            var requiresOriginalForSomeProcessing = requiresDurationComputation || requiresThumbnailComputation;
            var {
            mediaKey,
            encBodyPath,
            bodyPath,
            fileEncSha256,
            fileSha256,
            fileLength,
            didSaveToTmpPath
        } = await encryptedStream(media, mediaType, requiresOriginalForSomeProcessing);
            var fileEncSha256B64 = encodeURIComponent(fileEncSha256.toString("base64").replace(new RegExp("\\+", "g"), "-").replace(new RegExp("\\/", "g"), "_").replace(new RegExp("\\=+$"), ""));
            if (requiresThumbnailComputation)
            {
                await generateThumbnail(bodyPath, mediaType, options);
            }

            if (requiresDurationComputation)
            {
                try
                {
                    options.duration = await getAudioDuration(bodyPath);
                }
                catch (Exception error)
                {
                    this.logger.debug(new Dictionary<string, dynamic>() { { "error", error } }, "failed to obtain audio duration: " + error.message);
                }
            }

            var json = await this.refreshMediaConn(options.forceNewMediaOptions);
            string mediaUrl;
            foreach (var host in json.hosts)
            {
                var auth = encodeURIComponent(json.auth);
                var url = $"https://{host.hostname}{MediaPathMap[mediaType]}/{fileEncSha256B64}?auth={auth}&token={fileEncSha256B64}";
                try
                {
                    var {body: responseText} = await this.fetchRequest(url, "POST", createReadStream(encBodyPath), options.uploadAgent, new Dictionary<string, string>() { { "Content_Type", "application/octet-stream" } });
                    var result = JSON.parse(responseText);
                    mediaUrl = result.url;
                    if (mediaUrl)
                        break;
                    else
                    {
                        json = await this.refreshMediaConn(true);
                        throw new Error($"upload failed, reason: {JSON.stringify(result)}");
                    }
                }
                catch (Exception error)
                {
                    var isLast = host.hostname == json.hosts[json.hosts.length - 1].hostname;
                    this.logger.error($"Error in uploading to {host.hostname} ({error}) {isLast ? "" : ", retrying..."}");
                }
            }

            if (!mediaUrl)
                throw new Error("Media upload failed on all hosts");
            await Promise.all(new List<dynamic> { fs.unlink(encBodyPath), didSaveToTmpPath && bodyPath && fs.unlink(bodyPath) }.filter(Boolean));
            var message = new Dictionary<string, dynamic>()
            {
                {
                    "[mediaType]",
                    MessageTypeProto[mediaType].fromObject((url: mediaUrl, mediaKey: mediaKey, mimetype: options.mimetype, fileEncSha256: fileEncSha256, fileSha256: fileSha256, fileLength: fileLength, seconds: options.duration, fileName: options.filename || "file", gifPlayback: isGIF || undefined, caption: options.caption, ptt: options.ptt, viewOnce: options.viewOnce, isAnimated: options.isAnimated))
                }
            };
            return WAMessageProto.Message.fromObject(message);
        }

        /// <summary>
        /// prepares a WAMessage for sending from the given content & options
        /// </summary>
        public void prepareMessageFromContent(string id, WAMessageContent message, MessageOptions options)
        {
            if (!options.timestamp)
                options.timestamp = new Date();
            if (TypeOf(options.sendEphemeral) == "undefined")
                options.sendEphemeral = "chat";
            if (options.viewOnce)
                message = new WAMessageContent()
                {
                    {
                        "viewOnceMessage",
                        new Dictionary<string, dynamic>()
                        {
                            {
                                "message",
                                message
                            }
                        }
                    }
                };
            id = whatsappID(id);
            var key = Object.keys(message)[0];
            var timestamp = unixTimestampSeconds(options.timestamp);
            var quoted = options.quoted;
            if (options.contextInfo)
                message[key].contextInfo = options.contextInfo;
            if (quoted)
            {
                var participant = quoted.key.fromMe ? this.user.jid : (quoted.participant || quoted.key.participant || quoted.key.remoteJid);
                message[key].contextInfo = message[key].contextInfo || new Dictionary<string, dynamic>();
                message[key].contextInfo.participant = participant;
                message[key].contextInfo.stanzaId = quoted.key.id;
                message[key].contextInfo.quotedMessage = quoted.message;
                if (quoted.key.participant)
                {
                    message[key].contextInfo.remoteJid = quoted.key.remoteJid;
                }
            }

            if (options.thumbnail)
            {
                message[key].jpegThumbnail = Buffer.from(options.thumbnail, "base64");
            }

            var chat = this.chats.get(id);
            if (((options.sendEphemeral == "chat" && chat.ephemeral) || options.sendEphemeral == true) && key != "protocolMessage" && key != "ephemeralMessage")
            {
                message[key].contextInfo = ((expiration: chat.ephemeral || WA_DEFAULT_EPHEMERAL, ephemeralSettingTimestamp: chat.eph_setting_ts)).Spread((message[key].contextInfo || new Dictionary<string, dynamic>()));
                message = new WAMessageContent()
                {
                    {
                        "ephemeralMessage",
                        new Dictionary<string, dynamic>()
                        {
                            {
                                "message",
                                message
                            }
                        }
                    }
                };
            }

            message = WAMessageProto.Message.fromObject(message);
            var messageJSON = (key: (remoteJid: id, fromMe: true, id: options.messageId || generateMessageID()), message: message, messageTimestamp: timestamp, messageStubParameters: new dynamic(), participant: id.includes("@g.us") ? this.user.jid : null, status: WA_MESSAGE_STATUS_TYPE.PENDING);
            return WAMessageProto.WebMessageInfo.fromObject(messageJSON);
        }

        /// <summary>
        /// Relay (send) a WAMessage; more advanced functionality to send a built WA Message, you may want to stick with sendMessage()
        /// </summary>
        async public void relayWAMessage(WAMessage message, Dictionary<string, bool> { waitForAck } = new Dictionary<string, bool>()
        {
            {
                "waitForAck",
                true
            }
        }

        )
        {
            var json = new List<string>
            {
                "action",
                (epoch: this.msgCount.toString(), type: "relay"),
                new List<string>
                {
                    new List<dynamic>
                    {
                        "message",
                        null,
                        message
                    }
                }
            };
            var flag = message.key.remoteJid == this.user.jid ? WAFlag.acknowledge : WAFlag.ignore;
            var mID = message.key.id;
            message.status = WA_MESSAGE_STATUS_TYPE.PENDING;
            var promise = this.query(new WAQuery() { { "json", json }, { "binaryTags", new List<WAMetric> { WAMetric.message, flag } }, { "tag", mID }, { "expect200", true }, { "requiresPhoneConnection", true } }).then(() => message.status = WA_MESSAGE_STATUS_TYPE.SERVER_ACK);
            if (waitForAck)
            {
                await promise;
            }
            else
            {
                var emitUpdate = (status) =>
                {
                    message.status = status;
                    this.emit("chat-update", (jid: message.key.remoteJid, messages: newMessagesDB(new List<WAMessage> { message })));
                };
                promise.then(() => emitUpdate(WA_MESSAGE_STATUS_TYPE.SERVER_ACK)).@catch(() => emitUpdate(WA_MESSAGE_STATUS_TYPE.ERROR));
            }

            await this.chatAddMessageAppropriate(message);
        }

        /// <summary>
        /// Fetches the latest url & media key for the given message.
        /// You may need to call this when the message is old & the content is deleted off of the WA servers
        /// </summary>
        /// <param name = "message">
        /// </param>
        async public void updateMediaMessage(WAMessage message)
        {
            var content = message.message.audioMessage || message.message.videoMessage || message.message.imageMessage || message.message.stickerMessage || message.message.documentMessage;
            if (!content)
                throw new BaileysError($"given message {message.key.id} is not a media message", message);
            var query = new List<string>
            {
                "query",
                (type: "media", index: message.key.id, owner: message.key.fromMe ? "true" : "false", jid: message.key.remoteJid, epoch: this.msgCount.toString()),
                null
            };
            var response = await this.query(new WAQuery() { { "json", query }, { "binaryTags", new List<WAMetric> { WAMetric.queryMedia, WAFlag.ignore } }, { "expect200", true }, { "requiresPhoneConnection", true } });
            Object.keys(response[1]).forEach((key) => content[key] = response[1][key]);
        }

        async public Promise<Buffer> downloadMediaMessage(WAMessage message);
        async public Promise<Buffer> downloadMediaMessage(WAMessage message, string /*buffer*/ type);
        async public Promise<Readable> downloadMediaMessage(WAMessage message, string /*stream*/ type);
        /// <summary>
        /// Securely downloads the media from the message. 
        /// Renews the download url automatically, if necessary.
        /// </summary>
        async public void downloadMediaMessage(WAMessage message, string /*buffer*/ type = "buffer")
        {
            var mContent = message.message.ephemeralMessage.message || message.message;
            if (!mContent)
                throw new BaileysError("No message present", new Dictionary<string, int>() { { "status", 400 } });
            var downloadMediaMessage = () =>
            {
                var stream = await decryptMediaMessageBuffer(mContent);
                if (type == "buffer")
                {
                    var buffer = Buffer.from(new dynamic());
                    foreach (var chunk in stream)
                    {
                        buffer = Buffer.concat(new dynamic { buffer, chunk });
                    }

                    return buffer;
                }

                return stream;
            };
            try
            {
                var buff = await downloadMediaMessage();
                return buff;
            }
            catch (Exception error)
            {
                if (error is BaileysError && (error as BaileysError).status == 404)
                {
                    this.logger.info($"updating media of message: {message.key.id}");
                    await this.updateMediaMessage(message);
                    mContent = message.message.ephemeralMessage.message || message.message;
                    var buff = await downloadMediaMessage();
                    return buff;
                }

                throw error;
            }
        }

        /// <summary>
        /// Securely downloads the media from the message and saves to a file. 
        /// Renews the download url automatically, if necessary.
        /// </summary>
        /// <param name = "message">
        /// the media message you want to decode
        /// </param>
        /// <param name = "filename">
        /// the name of the file where the media will be saved
        /// </param>
        /// <param name = "attachExtension">
        /// should the parsed extension be applied automatically to the file
        /// </param>
        async public void downloadAndSaveMediaMessage(WAMessage message, string filename, bool attachExtension = true)
        {
            var extension = extensionForMediaMessage(message.message);
            var trueFileName = attachExtension ? (filename + "." + extension) : filename;
            var buffer = await this.downloadMediaMessage(message);
            await fs.writeFile(trueFileName, buffer);
            return trueFileName;
        }

        /// <summary>
        /// Query a string to check if it has a url, if it does, return required extended text message
        /// </summary>
        async public void generateLinkPreview(string text)
        {
            var query = new List<string>
            {
                "query",
                (type: "url", url: text, epoch: this.msgCount.toString()),
                null
            };
            var response = await this.query(new WAQuery() { { "json", query }, { "binaryTags", new List<double> { 26, WAFlag.ignore } }, { "expect200", true }, { "requiresPhoneConnection", false } });
            if (response[1])
                response[1].jpegThumbnail = response[2];
            var data = response[1] as WAUrlInfo;
            var content = new Dictionary<string, dynamic>()
            {
                {
                    "text",
                    text
                }
            }

            as WATextMessage;
            content.canonicalUrl = data["canonical-url"];
            content.matchedText = data["matched-text"];
            content.jpegThumbnail = data.jpegThumbnail;
            content.description = data.description;
            content.title = data.title;
            content.previewType = 0;
            return content;
        }

        protected async void refreshMediaConn(bool forceGet = false)
        {
            if (!this.mediaConn || forceGet || (new Date().getTime() - this.mediaConn.fetchDate.getTime()) > this.mediaConn.ttl * 1000)
            {
                this.mediaConn = await this.getNewMediaConn();
                this.mediaConn.fetchDate = new Date();
            }

            return this.mediaConn;
        }

        protected async void getNewMediaConn()
        {
            var {media_conn} = await this.query(new WAQuery() { { "json", new List<string> { "query", "mediaConn" } }, { "requiresPhoneConnection", false } });
            return media_conn as MediaConnInfo;
        }
    }
}