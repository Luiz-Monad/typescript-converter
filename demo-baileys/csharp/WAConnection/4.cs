/// This file was generated by C# converter tool
/// Any changes made to this file manually will be lost next time the file is regenerated.

using System.Linq;
using TypeScript.CSharp;
using Base = Bailey.WAConnection;

namespace Bailey
{
    public class WAConnection : Base
    {
        public WAConnection(): base()
        {
            this.setMaxListeners(30);
            this.chatsDebounceTimeout.setTask(() =>
            {
                this.logger.debug("pinging with chats query");
                this.sendChatsQuery(this.msgCount);
                this.chatsDebounceTimeout.start();
            }

            );
            this.on("open", () =>
            {
                this.sendBinary(new WANode{"query", (type: "contacts", epoch: "1"), null}, new WATag{WAMetric.queryContact, WAFlag.ignore});
                this.sendBinary(new WANode{"query", (type: "status", epoch: "1"), null}, new WATag{WAMetric.queryStatus, WAFlag.ignore});
                this.sendBinary(new WANode{"query", (type: "quick_reply", epoch: "1"), null}, new WATag{WAMetric.queryQuickReply, WAFlag.ignore});
                this.sendBinary(new WANode{"query", (type: "label", epoch: "1"), null}, new WATag{WAMetric.queryLabel, WAFlag.ignore});
                this.sendBinary(new WANode{"query", (type: "emoji", epoch: "1"), null}, new WATag{WAMetric.queryEmoji, WAFlag.ignore});
                this.sendBinary(new WANode{"action", (type: "set", epoch: "1"), new Array<WANode>{new Array<dynamic>{"presence", new Hashtable<String, Presence>()
                {{"type", Presence.available}}, null}}}, new WATag{WAMetric.presence, WAFlag.available});
                if (this.connectOptions.queryChatsTillReceived)
                {
                    this.chatsDebounceTimeout.start();
                }
                else
                {
                    this.sendChatsQuery(1);
                }

                this.logger.debug("sent init queries");
            }

            );
            this.on("CB:Cmd,type:disconnect", (json) => (this.state == "open" && this.unexpectedDisconnect(json[1].kind || "unknown")));
            this.on("CB:Pong", (json) =>
            {
                if (!json[1])
                {
                    this.unexpectedDisconnect(DisconnectReason.close);
                    this.logger.info("Connection terminated by phone, closing...");
                }
                else if (this.phoneConnected != json[1])
                {
                    this.phoneConnected = json[1];
                    this.emit("connection-phone-change", new Array<dynamic>()
                    {{"connected", this.phoneConnected}});
                }
            }

            );
            this.on("CB:response,type:chat", (json) =>
            {
                if (json[1].duplicate || !json[2])
                    return;
                this.chatsDebounceTimeout.cancel();
                var chats = new KeyedDB(this.chatOrderingKey, (c) => c.jid);
                json[2].forEach(([item, chat]) =>
                {
                    if (!chat)
                    {
                        this.logger.warn($"unexpectedly got null chat: {item}", chat);
                        return;
                    }

                    chat.jid = whatsappID(chat.jid);
                    chat.t = +chat.t;
                    chat.count = +chat.count;
                    chat.messages = newMessagesDB();
                    chats.insertIfAbsent(chat);
                }

                );
                this.logger.info($"received {json[2].length} chats");
                var oldChats = this.chats;
                var updatedChats = new Array<dynamic>();
                var hasNewChats = false;
                chats.all().forEach((chat) =>
                {
                    var respectiveContact = this.contacts[chat.jid];
                    chat.name = respectiveContact.name || respectiveContact.notify || chat.name;
                    var oldChat = oldChats.get(chat.jid);
                    if (!oldChat)
                    {
                        hasNewChats = true;
                    }
                    else
                    {
                        chat.messages = oldChat.messages;
                        if (oldChat.t != chat.t || oldChat.modify_tag != chat.modify_tag)
                        {
                            var changes = shallowChanges(oldChat, chat, new Hashtable<String, bool>()
                            {{"lookForDeletedKeys", true}});
                            AAA___ delete  chat . metadata  ___AAA ;
                            AAA___ // remove group metadata as that may have changed; TODO, write better mechanism for this
                            delete  changes . messages  ___AAA ;
                            updatedChats.push((__spread__: changes, jid: chat.jid));
                        }
                    }
                }

                );
                this.chats = chats;
                this.lastChatsReceived = new Date();
                updatedChats.Count > 0 && this.emit("chats-update", updatedChats);
                this.emit("chats-received", new Array<dynamic>()
                {{"hasNewChats", hasNewChats}});
            }

            );
            var lastMessages = new Hashtable<String, dynamic>();
            Hashtable<String, (bool requiresOverlap, bool didOverlap)> overlaps = new Hashtable<String, (bool requiresOverlap, bool didOverlap)>();
            var onLastBatchOfDataReceived = () =>
            {
                var chatsWithMissingMessages = Object.keys(overlaps).map((jid) =>
                {
                    if (!overlaps[jid].didOverlap && overlaps[jid].requiresOverlap)
                    {
                        this.logger.debug($"received messages for {jid}, but did not overlap with previous messages, clearing...");
                        var chat = this.chats.get(jid);
                        if (chat)
                        {
                            var message = chat.messages.get(lastMessages[jid]);
                            var remainingMessages = chat.messages.paginatedByValue(message, this.maxCachedMessages, undefined, "after");
                            chat.messages = newMessagesDB(new dynamic{message, AAA___...remainingMessages ___AAA });
                            return (jid: jid, count: chat.messages.length);
                        }
                    }
                }

                ).filter(Boolean);
                this.emit("initial-data-received", new Array<dynamic>()
                {{"chatsWithMissingMessages", chatsWithMissingMessages}});
            }

            ;
            var messagesUpdate = (json, style) =>
            {
                this.messagesDebounceTimeout.start(undefined, onLastBatchOfDataReceived);
                if (style == "last")
                {
                    overlaps = new Hashtable<String, (bool requiresOverlap, bool didOverlap)>();
                }

                var messages = json[2].AsArray<WANode>();
                if (messages)
                {
                    Hashtable<String, KeyedDB<WAMessage, String>> updates = new Hashtable<String, KeyedDB<WAMessage, String>>();
                    messages.reverse().forEach(([,, message]) =>
                    {
                        var jid = message.key.remoteJid;
                        var chat = this.chats.get(jid);
                        var mKeyID = WA_MESSAGE_ID(message);
                        if (chat)
                        {
                            if (style == "previous")
                            {
                                var fm = chat.messages.get(lastMessages[jid]);
                                if (!fm)
                                    return;
                                var prevEpoch = fm["epoch"];
                                message["epoch"] = prevEpoch - 1;
                            }
                            else if (style == "last")
                            {
                                overlaps[jid] = new(bool requiresOverlap, bool didOverlap)()
                                {{"requiresOverlap", chat.messages.length > 0}};
                                var lm = chat.messages.all()[chat.messages.length - 1];
                                var prevEpoch = (lm && lm["epoch"]) || 0;
                                message["epoch"] = prevEpoch + 1000;
                            }

                            if (chat.messages.upsert(message).length > 0)
                            {
                                overlaps[jid] = (__spread__: (overlaps[jid] || new Hashtable<String, bool>()
                                {{"requiresOverlap", true}}), didOverlap: true);
                            }

                            updates[jid] = updates[jid] || newMessagesDB();
                            updates[jid].upsert(message);
                            lastMessages[jid] = mKeyID;
                        }
                        else if (!chat)
                            this.logger.debug(new Hashtable<String, dynamic>()
                            {{"jid", jid}}, $"chat not found");
                    }

                    );
                    if (Object.keys(updates).length > 0)
                    {
                        this.emit("chats-update", Object.keys(updates).map((jid) => ((jid: jid, messages: updates[jid]))));
                    }
                }
            }

            ;
            this.on("CB:action,add:last", (json) => messagesUpdate(json, "last"));
            this.on("CB:action,add:before", (json) => messagesUpdate(json, "previous"));
            this.on("CB:action,add:unread", (json) => messagesUpdate(json, "previous"));
            this.on("CB:response,type:contacts", (json) =>
            {
                if (json[1].duplicate || !json[2])
                    return;
                var contacts = this.contacts;
                Array<WAContact> updatedContacts = new Array<WAContact>();
                json[2].forEach(([type, contact]) =>
                {
                    if (!contact)
                        return this.logger.info($"unexpectedly got null contact: {type}", contact);
                    contact.jid = whatsappID(contact.jid);
                    var presentContact = contacts[contact.jid];
                    if (presentContact)
                    {
                        var changes = shallowChanges(presentContact, contact, new Hashtable<String, bool>()
                        {{"lookForDeletedKeys", false}});
                        if (changes && Object.keys(changes).length > 0)
                        {
                            updatedContacts.push((__spread__: changes, jid: contact.jid));
                        }
                    }
                    else
                        updatedContacts.push(contact);
                    contacts[contact.jid] = new WAContact();
                }

                );
                var updatedChats = new Array<dynamic>();
                this.chats.all().forEach((c) =>
                {
                    var contact = contacts[c.jid];
                    if (contact)
                    {
                        var name = contact.name || contact.notify || c.name;
                        if (name != c.name)
                        {
                            updatedChats.push((jid: c.jid, name: name));
                        }
                    }
                }

                );
                updatedChats.Count > 0 && this.emit("chats-update", updatedChats);
                this.logger.info($"received {json[2].length} contacts");
                this.contacts = contacts;
                this.emit("contacts-received", new Array<dynamic>()
                {{"updatedContacts", updatedContacts}});
            }

            );
            this.on("CB:action,add:relay,message", (json) =>
            {
                var message = json[2][0][2] as WAMessage;
                this.chatAddMessageAppropriate(message);
            }

            );
            this.on("CB:Chat,cmd:action", (json) =>
            {
                var data = json[1].data;
                if (data)
                {
                    var emitGroupParticipantsUpdate = (action) => this.emitParticipantsUpdate(json[1].id, data[2].participants.map(whatsappID), action);
                    var emitGroupUpdate = (data) => this.emitGroupUpdate(json[1].id, data);
                    switch (data[0])
                    {
                        case "promote":
                            emitGroupParticipantsUpdate("promote");
                            break;
                        case "demote":
                            emitGroupParticipantsUpdate("demote");
                            break;
                        case "desc_add":
                            emitGroupUpdate((__spread__: data[2], descOwner: data[1]));
                            break;
                        default:
                            this.logger.debug(new Hashtable<String, bool>()
                            {{"unhandled", true}}, json);
                            break;
                    }
                }
            }

            );
            this.on("CB:Presence", (json) =>
            {
                var chatUpdate = this.applyingPresenceUpdate(json[1]);
                chatUpdate && this.emit("chat-update", chatUpdate);
            }

            );
            this.on("CB:action,add:update,message", (json) =>
            {
                WAMessage message = json[2][0][2];
                var jid = whatsappID(message.key.remoteJid);
                var chat = this.chats.get(jid);
                if (!chat)
                    return;
                var oldMessage = chat.messages.get(WA_MESSAGE_ID(message));
                if (oldMessage)
                {
                    message["epoch"] = oldMessage["epoch"];
                    if (chat.messages.upsert(message).length)
                    {
                        Partial<WAChat> chatUpdate = new Partial<WAChat>()
                        {{"jid", jid}, {"messages", newMessagesDB(new Array<WAMessage>{message})}};
                        this.emit("chat-update", chatUpdate);
                    }
                }
                else
                {
                    this.logger.debug(new Hashtable<String, bool>()
                    {{"unhandled", true}}, "received message update for non-present message from " + jid);
                }
            }

            );
            var onMessageStatusUpdate = (json) =>
            {
                json = json[2][0][1];
                var MAP = (read: WA_MESSAGE_STATUS_TYPE.READ, message: WA_MESSAGE_STATUS_TYPE.DELIVERY_ACK, error: WA_MESSAGE_STATUS_TYPE.ERROR);
                this.onMessageStatusUpdate(whatsappID(json.jid), (id: json.index, fromMe: json.owner == "true"), MAP[json.type]);
            }

            ;
            this.on("CB:action,add:relay,received", onMessageStatusUpdate);
            this.on("CB:action,,received", onMessageStatusUpdate);
            this.on("CB:Msg,cmd:ack", (json) => (this.onMessageStatusUpdate(whatsappID(json[1].to), (id: json[1].id, fromMe: true), +json[1].ack + 1)));
            this.on("CB:action,,user", (json) =>
            {
                var node = json[2][0];
                if (node)
                {
                    var user = node[1] as WAContact;
                    user.jid = whatsappID(user.jid);
                    this.contacts[user.jid] = user;
                    this.emit("contact-update", user);
                    var chat = this.chats.get(user.jid);
                    if (chat)
                    {
                        chat.name = user.name || user.notify || chat.name;
                        this.emit("chat-update", new Array<dynamic>()
                        {{"jid", chat.jid}, {"name", chat.name}});
                    }
                }
            }

            );
            this.on("CB:action,,chat", (json) =>
            {
                json = json[2][0];
                var updateType = json[1].type;
                var jid = whatsappID(json[1].jid);
                var chat = this.chats.get(jid);
                if (!chat)
                    return;
                var FUNCTIONS = (delete: () =>
                {
                    chat["delete"] = "true";
                    this.chats.deleteById(chat.jid);
                    return "delete";
                }

                , clear: () =>
                {
                    if (!json[2])
                        chat.messages.clear();
                    else
                        json[2].forEach((item) => chat.messages.filter((m) => m.key.id != item[1].index));
                    return "clear";
                }

                , archive: () =>
                {
                    this.chats.update(chat.jid, (chat) => chat.archive = "true");
                    return "archive";
                }

                , unarchive: () =>
                {
                    AAA___ delete  chat . archive  ___AAA ;
                    return "archive";
                }

                , pin: () =>
                {
                    chat.pin = json[1].pin;
                    return "pin";
                }

                );
                var func = FUNCTIONS[updateType];
                if (func)
                {
                    var property = func();
                    this.emit("chat-update", new Array<dynamic>()
                    {{"jid", jid}, {"[property]", chat[property] || "false"}});
                }
            }

            );
            this.on("CB:Cmd,type:picture", (json) =>
            {
                json = json[1];
                var jid = whatsappID(json.jid);
                var imgUrl = await this.getProfilePicture(jid).catch(() => "");
                var contact = this.contacts[jid];
                if (contact)
                {
                    contact.imgUrl = imgUrl;
                    this.emit("contact-update", new Array<dynamic>()
                    {{"jid", jid}, {"imgUrl", imgUrl}});
                }

                var chat = this.chats.get(jid);
                if (chat)
                {
                    chat.imgUrl = imgUrl;
                    this.emit("chat-update", new Array<dynamic>()
                    {{"jid", jid}, {"imgUrl", imgUrl}});
                }
            }

            );
            this.on("CB:Status,status", (json) =>
            {
                var jid = whatsappID(json[1].id);
                this.emit("contact-update", new Array<dynamic>()
                {{"jid", jid}, {"status", json[1].status}});
            }

            );
            this.on("CB:Conn,pushname", (json) =>
            {
                if (this.user)
                {
                    var name = json[1].pushname;
                    if (this.user.name != name)
                    {
                        this.user.name = name;
                        this.emit("contact-update", new Array<dynamic>()
                        {{"jid", this.user.jid}, {"name", name}});
                    }
                }
            }

            );
            this.on("CB:action,,read", (json) =>
            {
                var update = json[2][0][1];
                var jid = whatsappID(update.jid);
                var chat = this.chats.get(jid);
                if (chat)
                {
                    if (update.type == "false")
                        chat.count = -1;
                    else
                        chat.count = 0;
                    this.emit("chat-update", new Array<dynamic>()
                    {{"jid", chat.jid}, {"count", chat.count}});
                }
                else
                {
                    this.logger.warn("recieved read update for unknown chat " + jid);
                }
            }

            );
            this.on("qr", (qr) =>
            {
                if (this.connectOptions.logQR)
                {
                    QR.generate(qr, new Hashtable<String, bool>()
                    {{"small", true}});
                }
            }

            );
            this.on("CB:Blocklist", (json) =>
            {
                json = json[1];
                var initial = this.blocklist;
                this.blocklist = json.blocklist;
                var added = this.blocklist.filter((id) => !initial.includes(id));
                var removed = initial.filter((id) => !this.blocklist.includes(id));
                BlocklistUpdate update = new BlocklistUpdate()
                {{"added", added}, {"removed", removed}};
                this.emit("blocklist-update", update);
            }

            );
        }

        protected void sendChatsQuery(double epoch)
        {
            return this.sendBinary(new WANode{"query", (type: "chat", epoch: epoch.toString()), null}, new WATag{WAMetric.queryChat, WAFlag.ignore});
        }

        /// <summary>
        /// Get the URL to download the profile picture of a person/group
        /// </summary>
        async public void getProfilePicture(String jid)
        {
            var response = await this.query(new WAQuery()
            {{"json", new Array<String>{"query", "ProfilePicThumb", jid || this.user.jid}}, {"expect200", true}, {"requiresPhoneConnection", false}});
            return response.eurl as String;
        }

        protected void applyingPresenceUpdate(PresenceUpdate update)
        {
            var chatId = whatsappID(update.id);
            var jid = whatsappID(update.participant || update.id);
            var chat = this.chats.get(chatId);
            if (chat && jid.endsWith("@s.whatsapp.net"))
            {
                chat.presences = chat.presences || new Hashtable<String, dynamic>();
                var presence = new AAA___ ___AAA () as WAPresenceData;
                if (update.t)
                    presence.lastSeen = +update.t;
                else if (update.type == Presence.unavailable && (presence.lastKnownPresence == Presence.available || presence.lastKnownPresence == Presence.composing))
                {
                    presence.lastSeen = unixTimestampSeconds();
                }

                presence.lastKnownPresence = update.type;
                if (presence.lastKnownPresence == chat.presences[jid].lastKnownPresence && presence.lastSeen == chat.presences[jid].lastSeen)
                {
                    return;
                }

                var contact = this.contacts[jid];
                if (contact)
                {
                    presence.name = contact.name || contact.notify || contact.vname;
                }

                chat.presences[jid] = presence;
                return (jid: chatId, presences: new
                {
                [jid] = presence
                }

                ) as Partial<WAChat>;
            }
        }

        /// <summary>
        /// inserts an empty chat into the DB
        /// </summary>
        protected void chatAdd(String jid, String name = null, Partial<WAChat> properties = new Partial<WAChat>())
        {
            WAChat chat = new WAChat()
            {{"jid", jid}, {"name", name}, {"t", unixTimestampSeconds()}, {"messages", newMessagesDB()}, {"count", 0}};
            if (this.chats.insertIfAbsent(chat).length)
            {
                this.emit("chat-new", chat);
                return chat;
            }
        }

        protected void onMessageStatusUpdate(String jid, (String id, bool fromMe)key, WA_MESSAGE_STATUS_TYPE status)
        {
            var chat = this.chats.get(whatsappID(jid));
            var msg = chat.messages.get(GET_MESSAGE_ID(key));
            if (msg)
            {
                if (TypeOf(status) != "undefined")
                {
                    if (status > msg.status || status == WA_MESSAGE_STATUS_TYPE.ERROR)
                    {
                        msg.status = status;
                        this.emit("chat-update", new Array<dynamic>()
                        {{"jid", chat.jid}, {"messages", newMessagesDB(new Array<dynamic>{msg})}});
                    }
                }
                else
                {
                    this.logger.warn(new Hashtable<String, WA_MESSAGE_STATUS_TYPE>()
                    {{"update", status}}, "received unknown message status update");
                }
            }
            else
            {
                this.logger.debug((unhandled: true, update: status, key: key), "received message status update for non-present message");
            }
        }

        protected void contactAddOrGet(String jid)
        {
            jid = whatsappID(jid);
            if (!this.contacts[jid])
                this.contacts[jid] = new WAContact()
                {{"jid", jid}};
            return this.contacts[jid];
        }

        /// <summary>
        /// find a chat or return an error
        /// </summary>
        protected dynamic assertChatGet = (jid) =>
        {
            var chat = this.chats.get(jid);
            if (!chat)
                throw new Error($"chat '{jid}' not found");
            return chat;
        }

        ;
        /// <summary>
        /// Adds the given message to the appropriate chat, if the chat doesn't exist, it is created
        /// </summary>
        protected async void chatAddMessageAppropriate(WAMessage message)
        {
            var jid = whatsappID(message.key.remoteJid);
            var chat = this.chats.get(jid) || await this.chatAdd(jid);
            this.chatAddMessage(message, chat);
        }

        protected void chatAddMessage(WAMessage message, WAChat chat)
        {
            WAChatUpdate chatUpdate = new WAChatUpdate()
            {{"jid", chat.jid}};
            if (!message.key.fromMe && message.message)
            {
                chat.count += 1;
                chatUpdate.count = chat.count;
                var participant = whatsappID(message.participant || chat.jid);
                var contact = chat.presences && chat.presences[participant];
                if (contact.lastKnownPresence == Presence.composing)
                {
                    var update = this.applyingPresenceUpdate(new PresenceUpdate()
                    {{"id", chat.jid}, {"participant", participant}, {"type", Presence.available}});
                    update && Object.assign(chatUpdate, update);
                }
            }

            var ephemeralProtocolMsg = message.message.ephemeralMessage.message.protocolMessage;
            if (ephemeralProtocolMsg && ephemeralProtocolMsg.type == WAMessageProto.ProtocolMessage.ProtocolMessageType.EPHEMERAL_SETTING)
            {
                chatUpdate.eph_setting_ts = message.messageTimestamp.toString();
                chatUpdate.ephemeral = ephemeralProtocolMsg.ephemeralExpiration.toString();
                if (ephemeralProtocolMsg.ephemeralExpiration)
                {
                    chat.eph_setting_ts = chatUpdate.eph_setting_ts;
                    chat.ephemeral = chatUpdate.ephemeral;
                }
                else
                {
                    AAA___ delete  chat . eph_setting_ts  ___AAA ;
                    AAA___ delete  chat . ephemeral  ___AAA ;
                }
            }

            var messages = chat.messages;
            var protocolMessage = message.message.protocolMessage;
            if (protocolMessage)
            {
                switch (protocolMessage.type)
                {
                    case WAMessageProto.ProtocolMessage.ProtocolMessageType.REVOKE:
                        var found = chat.messages.get(GET_MESSAGE_ID(protocolMessage.key));
                        if (found.message)
                        {
                            this.logger.info("deleting message: " + protocolMessage.key.id + " in chat: " + protocolMessage.key.remoteJid);
                            found.messageStubType = WA_MESSAGE_STUB_TYPE.REVOKE;
                            AAA___ delete  found . message  ___AAA ;
                            chatUpdate.messages = newMessagesDB(new Array<dynamic>{found});
                        }

                        break;
                    default:
                        break;
                }
            }
            else if (!messages.get(WA_MESSAGE_ID(message)))
            {
                var lastEpoch = (messages.last && messages.last["epoch"]) || 0;
                message["epoch"] = lastEpoch + 1;
                messages.insert(message);
                while (messages.length > this.maxCachedMessages)
                {
                    messages.delete(messages.all()[0]);
                }

                if (message.message && !ephemeralProtocolMsg)
                {
                    this.chats.update(chat.jid, (chat) =>
                    {
                        chat.t = +toNumber(message.messageTimestamp);
                        chatUpdate.t = chat.t;
                        if (chat.archive)
                        {
                            AAA___ delete  chat . archive  ___AAA ;
                            chatUpdate.archive = "false";
                        }
                    }

                    );
                }

                chatUpdate.hasNewMessage = true;
                chatUpdate.messages = newMessagesDB(new Array<WAMessage>{message});
                if (message.messageStubType)
                {
                    var jid = chat.jid;
                    Array<String> participants;
                    var emitParticipantsUpdate = (action) => (this.emitParticipantsUpdate(jid, participants, action));
                    var emitGroupUpdate = (update) => this.emitGroupUpdate(jid, update);
                    switch (message.messageStubType)
                    {
                        case WA_MESSAGE_STUB_TYPE.CHANGE_EPHEMERAL_SETTING:
                            chatUpdate.eph_setting_ts = message.messageTimestamp.toString();
                            chatUpdate.ephemeral = message.messageStubParameters[0];
                            if (+chatUpdate.ephemeral)
                            {
                                chat.eph_setting_ts = chatUpdate.eph_setting_ts;
                                chat.ephemeral = chatUpdate.ephemeral;
                            }
                            else
                            {
                                AAA___ delete  chat . eph_setting_ts  ___AAA ;
                                AAA___ delete  chat . ephemeral  ___AAA ;
                            }

                            break;
                        case WA_MESSAGE_STUB_TYPE.GROUP_PARTICIPANT_LEAVE:
                        case WA_MESSAGE_STUB_TYPE.GROUP_PARTICIPANT_REMOVE:
                            participants = message.messageStubParameters.map(whatsappID);
                            emitParticipantsUpdate("remove");
                            if (participants.includes(this.user.jid))
                            {
                                chat.read_only = "true";
                                chatUpdate.read_only = "true";
                            }

                            break;
                        case WA_MESSAGE_STUB_TYPE.GROUP_PARTICIPANT_ADD:
                        case WA_MESSAGE_STUB_TYPE.GROUP_PARTICIPANT_INVITE:
                        case WA_MESSAGE_STUB_TYPE.GROUP_PARTICIPANT_ADD_REQUEST_JOIN:
                            participants = message.messageStubParameters.map(whatsappID);
                            if (participants.includes(this.user.jid) && chat.read_only == "true")
                            {
                                AAA___ delete  chat . read_only  ___AAA ;
                                chatUpdate.read_only = "false";
                            }

                            emitParticipantsUpdate("add");
                            break;
                        case WA_MESSAGE_STUB_TYPE.GROUP_CHANGE_ANNOUNCE:
                            var announce = message.messageStubParameters[0] == "on" ? "true" : "false";
                            emitGroupUpdate(new Hashtable<String, dynamic>()
                            {{"announce", announce}});
                            break;
                        case WA_MESSAGE_STUB_TYPE.GROUP_CHANGE_RESTRICT:
                            var restrict = message.messageStubParameters[0] == "on" ? "true" : "false";
                            emitGroupUpdate(new Hashtable<String, dynamic>()
                            {{"restrict", restrict}});
                            break;
                        case WA_MESSAGE_STUB_TYPE.GROUP_CHANGE_SUBJECT:
                        case WA_MESSAGE_STUB_TYPE.GROUP_CREATE:
                            chat.name = message.messageStubParameters[0];
                            chatUpdate.name = chat.name;
                            if (chat.metadata)
                                chat.metadata.subject = chat.name;
                            break;
                    }
                }
            }

            this.emit("chat-update", chatUpdate);
        }

        protected dynamic emitParticipantsUpdate = (jid, participants, action) =>
        {
            var chat = this.chats.get(jid);
            var meta = chat.metadata;
            if (meta)
            {
                switch (action)
                {
                    case "add":
                        participants.forEach((jid) => (meta.participants.push((__spread__: this.contactAddOrGet(jid), isAdmin: false, isSuperAdmin: false))));
                        break;
                    case "remove":
                        meta.participants = meta.participants.filter((p) => !participants.includes(p.jid));
                        break;
                    case "promote":
                    case "demote":
                        var isAdmin = action == "promote";
                        meta.participants.forEach((p) =>
                        {
                            if (participants.includes(p.jid))
                                p.isAdmin = isAdmin;
                        }

                        );
                        break;
                }
            }

            this.emit("group-participants-update", new Array<dynamic>()
            {{"jid", jid}, {"participants", participants}, {"action", action}});
        }

        ;
        protected dynamic emitGroupUpdate = (jid, update) =>
        {
            var chat = this.chats.get(jid);
            if (chat && chat.metadata)
                Object.assign(chat.metadata, update);
            this.emit("group-update", new Array<dynamic>()
            {{"jid", jid}});
        }

        ;
        protected dynamic chatUpdateTime = (chat, stamp) => this.chats.update(chat.jid, (c) => c.t = stamp);
        /// <summary>
        /// sets the profile picture of a chat
        /// </summary>
        protected async void setProfilePicture(WAChat chat)
        {
            chat.imgUrl = await this.getProfilePicture(chat.jid).catch((err) => "");
        }

        /// <summary>
        /// when the connection has opened successfully
        /// </summary>
        public  this  on(dynamic event, AAA___ (result: WAOpenResult) => void ___AAA listener);
        /// <summary>
        /// when the connection is opening
        /// </summary>
        public  this  on(dynamic event, AAA___ () => void ___AAA listener);
        /// <summary>
        /// when the connection has closed
        /// </summary>
        public  this  on(dynamic event, AAA___ (err: {reason?: DisconnectReason | string, isReconnecting: boolean}) => void ___AAA listener);
        /// <summary>
        /// when the socket is closed
        /// </summary>
        public  this  on(dynamic event, AAA___ (err: {reason?: DisconnectReason | string}) => void ___AAA listener);
        /// <summary>
        /// when a new QR is generated, ready for scanning
        /// </summary>
        public  this  on(dynamic event, AAA___ (qr: string) => void ___AAA listener);
        /// <summary>
        /// when the connection to the phone changes
        /// </summary>
        public  this  on(dynamic event, AAA___ (state: {connected: boolean}) => void ___AAA listener);
        /// <summary>
        /// when a contact is updated
        /// </summary>
        public  this  on(dynamic event, AAA___ (update: WAContactUpdate) => void ___AAA listener);
        /// <summary>
        /// when a new chat is added
        /// </summary>
        public  this  on(dynamic event, AAA___ (chat: WAChat) => void ___AAA listener);
        /// <summary>
        /// when contacts are sent by WA
        /// </summary>
        public  this  on(dynamic event, AAA___ (u: { updatedContacts: Partial<WAContact>[] }) => void ___AAA listener);
        /// <summary>
        /// when chats are sent by WA, and when all messages are received
        /// </summary>
        public  this  on(dynamic event, AAA___ (update: {hasNewChats?: boolean}) => void ___AAA listener);
        /// <summary>
        /// when all initial messages are received from WA
        /// </summary>
        public  this  on(dynamic event, AAA___ (update: {chatsWithMissingMessages: { jid: string, count: number }[] }) => void ___AAA listener);
        /// <summary>
        /// when multiple chats are updated (new message, updated message, deleted, pinned, etc)
        /// </summary>
        public  this  on(dynamic event, AAA___ (chats: WAChatUpdate[]) => void ___AAA listener);
        /// <summary>
        /// when a chat is updated (new message, updated message, read message, deleted, pinned, presence updated etc)
        /// </summary>
        public  this  on(dynamic event, AAA___ (chat: WAChatUpdate) => void ___AAA listener);
        /// <summary>
        /// when participants are added to a group
        /// </summary>
        public  this  on(dynamic event, AAA___ (update: {jid: string, participants: string[], actor?: string, action: WAParticipantAction}) => void ___AAA listener);
        /// <summary>
        /// when the group is updated
        /// </summary>
        public  this  on(dynamic event, AAA___ (update: Partial<WAGroupMetadata> & {jid: string, actor?: string}) => void ___AAA listener);
        /// <summary>
        /// when WA sends back a pong
        /// </summary>
        public  this  on(dynamic event, AAA___ () => void ___AAA listener);
        /// <summary>
        /// when a user is blocked or unblockd
        /// </summary>
        public  this  on(dynamic event, AAA___ (update: BlocklistUpdate) => void ___AAA listener);
        public  this  on(dynamic event, AAA___ (json: any) => void ___AAA listener);
        public void on(dynamic event, AAA___ (...args: any[]) => void ___AAA listener)
        {
            return base.on(event, listener);
        }

        public void emit(dynamic event, params dynamic[] args)
        {
            return base.emit(event, args);
        }
    }
}