/// This file was generated by C# converter tool
/// Any changes made to this file manually will be lost next time the file is regenerated.

using System.Linq;
using TypeScript.CSharp;
using Base = Bailey.WAConnection;

namespace Bailey
{
    public class WAConnection : Base
    {
        async public void loadAllUnreadMessages()
        {
            var tasks = this.chats.all().filter((chat) => chat.count > 0).map((chat) => this.loadMessages(chat.jid, chat.count));
            var list = await Promise.all(tasks);
            Array<WAMessage> combined = new Array<WAMessage>();
            list.forEach(({messages}) => combined.push(messages.ToArray()));
            return combined;
        }

        /// <summary>
        /// Get the message info, who has read it, who its been delivered to
        /// </summary>
        async public void messageInfo(String jid, String messageID)
        {
            var query = new Array<String>{"query", (type: "message_info", index: messageID, jid: jid, epoch: this.msgCount.toString()), null};
            var [,,response] = await this.query(new WAQuery()
            {{"json", query}, {"binaryTags", new Array<WAMetric>{WAMetric.queryRead, WAFlag.ignore}}, {"expect200", true}, {"requiresPhoneConnection", true}});
            MessageInfo info = new MessageInfo()
            {{"reads", new Array<dynamic>()}, {"deliveries", new Array<dynamic>()}};
            if (response)
            {
                var reads = response.filter((node) => node[0] == "read");
                if (reads[0])
                {
                    info.reads = reads[0][2].map((item) => item[1]);
                }

                var deliveries = response.filter((node) => node[0] == "delivery");
                if (deliveries[0])
                {
                    info.deliveries = deliveries[0][2].map((item) => item[1]);
                }
            }

            return info;
        }

        /// <summary>
        /// Marks a chat as read/unread; updates the chat object too
        /// </summary>
        /// <param name = "jid">
        /// the ID of the person/group whose message you want to mark read
        /// </param>
        /// <param name = "unread">
        /// unreads the chat, if true
        /// </param>
        async public void chatRead(String jid, dynamic type = "read")
        {
            jid = whatsappID(jid);
            var chat = this.assertChatGet(jid);
            var count = type == "unread" ? "-2" : Math.abs(chat.count).toString();
            if (type == "unread" || chat.count != 0)
            {
                var idx = await this.getChatIndex(jid);
                await this.setQuery(new Array<WANode>{new Array<WANode>{"read", (jid: jid, count: count, __spread__: idx, participant: undefined), null}}, new WATag{WAMetric.read, WAFlag.ignore});
            }

            chat.count = type == "unread" ? -1 : 0;
            this.emit("chat-update", (jid: jid, count: chat.count));
        }

        /// <summary>
        /// Sends a read receipt for a given message;
        /// does not update the chat do @see chatReadjust use chatRead()
        /// </summary>
        /// <param name = "jid">
        /// the ID of the person/group whose message you want to mark read
        /// </param>
        /// <param name = "messageKey">
        /// the key of the message
        /// </param>
        /// <param name = "count">
        /// number of messages to read, set to < 0 to unread a message
        /// </param>
        async public void sendReadReceipt(String jid, WAMessageKey messageKey, double count)
        {
            var attributes = (jid: jid, count: count.toString(), index: messageKey.id, participant: messageKey.participant || undefined, owner: messageKey.fromMe.toString());
            var read = await this.setQuery(new Array<WANode>{new Array<WANode>{"read", attributes, null}}, new WATag{WAMetric.read, WAFlag.ignore});
            return read;
        }

        async public void fetchMessagesFromWA(String jid, double count, (String id, bool fromMe)indexMessage = null, bool mostRecentFirst = true)
        {
            var json = new Array<String>{"query", (epoch: this.msgCount.toString(), type: "message", jid: jid, kind: mostRecentFirst ? "before" : "after", count: count.toString(), index: indexMessage.id, owner: indexMessage.fromMe == false ? "false" : "true"), null};
            var response = await this.query(new WAQuery()
            {{"json", json}, {"binaryTags", new Array<WAMetric>{WAMetric.queryMessages, WAFlag.ignore}}, {"expect200", false}, {"requiresPhoneConnection", true}});
            return (response[2].AsArray<WANode>()).map((item) => item[2] as WAMessage) || new Array<dynamic>();
        }

        /// <summary>
        /// Load the conversation with a group or person
        /// </summary>
        /// <param name = "count">
        /// the number of messages to load
        /// </param>
        /// <param name = "cursor">
        /// the data for which message to offset the query by
        /// </param>
        /// <param name = "mostRecentFirst">
        /// retrieve the most recent message first or retrieve from the converation start
        /// </param>
        async public void loadMessages(String jid, double count, (String id, bool fromMe)cursor = null, bool mostRecentFirst = true)
        {
            jid = whatsappID(jid);
            var retrieve = (count, indexMessage) => this.fetchMessagesFromWA(jid, count, indexMessage, mostRecentFirst);
            var chat = this.chats.get(jid);
            var hasCursor = cursor.id && TypeOf(cursor.fromMe) != "undefined";
            var cursorValue = hasCursor && chat.messages.get(GET_MESSAGE_ID(cursor));
            Array<WAMessage> messages;
            if (chat.messages && mostRecentFirst && (!hasCursor || cursorValue))
            {
                messages = chat.messages.paginatedByValue(cursorValue, count, null, "before");
                var diff = count - messages.Count;
                if (diff < 0)
                {
                    messages = messages.slice(-count);
                }
                else if (diff > 0)
                {
                    var fMessage = chat.messages.all()[0];
                    var fepoch = (fMessage && fMessage["epoch"]) || 0;
                    var extra = await retrieve(diff, messages[0].key || cursor);
                    for (var i = extra.length - 1; i >= 0; i--)
                    {
                        var m = extra[i];
                        fepoch -= 1;
                        m["epoch"] = fepoch;
                        if (chat.messages.length < this.maxCachedMessages)
                        {
                            chat.messages.insertIfAbsent(m);
                        }
                    }

                    messages.unshift(extra.ToArray());
                }
            }
            else
                messages = await retrieve(count, cursor);
            if (messages[0])
                cursor = (id: messages[0].key.id, fromMe: messages[0].key.fromMe);
            else
                cursor = null;
            return new void ()
            {{"messages", messages}, {"cursor", cursor}};
        }

        /// <summary>
        /// Load the entire friggin conversation with a group or person
        /// </summary>
        /// <param name = "onMessage">
        /// callback for every message retrieved
        /// </param>
        /// <param name = "chunkSize">
        /// the number of messages to load in a single request
        /// </param>
        /// <param name = "mostRecentFirst">
        /// retrieve the most recent message first or retrieve from the converation start
        /// </param>
        public void loadAllMessages(String jid, AAA___ (m: WAMessage) => Promise<void>|void ___AAA onMessage, int chunkSize = 25, bool mostRecentFirst = true)
        {
            dynamic offsetID = null;
            var loadMessage = () =>
            {
                var {messages} = await this.loadMessages(jid, chunkSize, offsetID, mostRecentFirst);
                dynamic lastMessage;
                if (mostRecentFirst)
                {
                    for (var i = messages.length - 1; i >= 0; i--)
                    {
                        await onMessage(messages[i]);
                        lastMessage = messages[i];
                    }
                }
                else
                {
                    for (var i = 0; i < messages.length; i++)
                    {
                        await onMessage(messages[i]);
                        lastMessage = messages[i];
                    }
                }

                if (messages.length >= chunkSize)
                {
                    offsetID = lastMessage.key;
                    await delay(200);
                    return loadMessage();
                }
            }

            ;
            return loadMessage() as Promise<void>;
        }

        /// <summary>
        /// Find a message in a given conversation
        /// </summary>
        /// <param name = "chunkSize">
        /// the number of messages to load in a single request
        /// </param>
        /// <param name = "onMessage">
        /// callback for every message retrieved, if return true -- the loop will break
        /// </param>
        async public void findMessage(String jid, double chunkSize, AAA___ (m: WAMessage) => boolean ___AAA onMessage)
        {
            var chat = this.chats.get(whatsappID(jid));
            var count = chat.messages.all().length || chunkSize;
            dynamic offsetID;
            while (true)
            {
                var {messages, cursor} = await this.loadMessages(jid, count, offsetID, true);
                for (var i = messages.length - 1; i >= 0; i--)
                {
                    if (onMessage(messages[i]))
                        return;
                }

                if (messages.length == 0)
                    return;
                offsetID = cursor;
                await delay(200);
            }
        }

        /// <summary>
        /// Loads all messages sent after a specific date
        /// </summary>
        async public void messagesReceivedAfter(Date date, bool onlyUnrespondedMessages = false)
        {
            var stamp = unixTimestampSeconds(date);
            var idx = this.chats.all().findIndex((c) => c.t < stamp);
            var chats = this.chats.all().slice(0, idx);
            Array<WAMessage> messages = new Array<WAMessage>();
            await Promise.all(chats.map((chat) =>
            {
                await this.findMessage(chat.jid, 5, (m) =>
                {
                    if (toNumber(m.messageTimestamp) < stamp || (onlyUnrespondedMessages && m.key.fromMe))
                        return true;
                    messages.push(m);
                }

                );
            }

            ));
            return messages;
        }

        /// <summary>
        /// Load a single message specified by the ID
        /// </summary>
        async public void loadMessage(String jid, String id)
        {
            WAMessage message;
            jid = whatsappID(jid);
            var chat = this.chats.get(jid);
            if (chat)
            {
                message = chat.messages.get(GET_MESSAGE_ID((id: id, fromMe: true))) || chat.messages.get(GET_MESSAGE_ID((id: id, fromMe: false)));
            }

            if (!message)
            {
                var messages = (await this.loadMessages(jid, 1, (id: id, fromMe: true))).messages;
                if (!messages[0])
                    messages = (await this.loadMessages(jid, 1, (id: id, fromMe: false))).messages;
                var actual = await this.loadMessages(jid, 1, messages[0] && messages[0].key, false);
                message = actual.messages[0];
            }

            return message;
        }

        /// <summary>
        /// Search WhatsApp messages with a given text string
        /// </summary>
        /// <param name = "txt">
        /// the search string
        /// </param>
        /// <param name = "inJid">
        /// the ID of the chat to search in, set to null to search all chats
        /// </param>
        /// <param name = "count">
        /// number of results to return
        /// </param>
        /// <param name = "page">
        /// page number of results (starts from 1)
        /// </param>
        async public void searchMessages(String txt, String inJid, double count, double page)
        {
            var json = new Array<String>{"query", (epoch: this.msgCount.toString(), type: "search", search: Buffer.from(txt, "utf-8"), count: count.toString(), page: page.toString(), jid: inJid), null};
            WANode response = await this.query(new WAQuery()
            {{"json", json}, {"binaryTags", new Array<double>{24, WAFlag.ignore}}, {"expect200", true}});
            var messages = response[2] ? response[2].map((row) => row[2]) : new Array<dynamic>();
            return new void ()
            {{"last", response[1]["last"] == "true"}, {"messages", messages.AsArray<WAMessage>()}};
        }

        /// <summary>
        /// Delete a message in a chat for yourself
        /// </summary>
        /// <param name = "messageKey">
        /// key of the message you want to delete
        /// </param>
        async public void clearMessage(WAMessageKey messageKey)
        {
            var tag = Math.round(Math.random() * 1000000);
            WANode attrs = new WANode{"chat", (jid: messageKey.remoteJid, modify_tag: tag.toString(), type: "clear"), new Array<WANode>{new Array<dynamic>{"item", (owner: $"{messageKey.fromMe}", index: messageKey.id), null}}};
            var result = await this.setQuery(new Array<WANode>{attrs});
            var chat = this.chats.get(whatsappID(messageKey.remoteJid));
            if (chat)
            {
                var value = chat.messages.get(GET_MESSAGE_ID(messageKey));
                value && chat.messages.delete(value);
            }

            return result;
        }

        /// <summary>
        /// Star or unstar a message
        /// </summary>
        /// <param name = "messageKey">
        /// key of the message you want to star or unstar
        /// </param>
        async public void starMessage(WAMessageKey messageKey, dynamic type = "star")
        {
            WANode attrs = new WANode{"chat", (jid: messageKey.remoteJid, type: type), new Array<WANode>{new Array<dynamic>{"item", (owner: $"{messageKey.fromMe}", index: messageKey.id), null}}};
            var result = await this.setQuery(new Array<WANode>{attrs});
            var chat = this.chats.get(whatsappID(messageKey.remoteJid));
            if (result.status == 200 && chat)
            {
                var message = chat.messages.get(GET_MESSAGE_ID(messageKey));
                if (message)
                {
                    message.starred = type == "star";
                    Partial<WAChat> chatUpdate = new Partial<WAChat>()
                    {{"jid", messageKey.remoteJid}, {"messages", newMessagesDB(new Array<dynamic>{message})}};
                    this.emit("chat-update", chatUpdate);
                }
            }

            return result;
        }

        /// <summary>
        /// Delete a message in a chat for everyone
        /// </summary>
        /// <param name = "id">
        /// the person or group where you're trying to delete the message
        /// </param>
        /// <param name = "messageKey">
        /// key of the message you want to delete
        /// </param>
        async public void deleteMessage(dynamic k, WAMessageKey messageKey = null)
        {
            if (TypeOf(k) == "object")
            {
                messageKey = k;
            }

            WAMessageContent json = new WAMessageContent()
            {{"protocolMessage", (key: messageKey, type: WAMessageProto.ProtocolMessage.ProtocolMessageType.REVOKE)}};
            var waMessage = this.prepareMessageFromContent(messageKey.remoteJid, json, new Hashtable<String, dynamic>());
            await this.relayWAMessage(waMessage);
            return waMessage;
        }

        /// <summary>
        /// Generate forwarded message content like WA does
        /// </summary>
        /// <param name = "message">
        /// the message to forward
        /// </param>
        /// <param name = "forceForward">
        /// will show the message as forwarded even if it is from you
        /// </param>
        public void generateForwardMessageContent(WAMessage message, bool forceForward = false)
        {
            var content = message.message;
            if (!content)
                throw new BaileysError("no content in message", new
                {
                status = 400
                }

                );
            content = WAMessageProto.Message.fromObject(content);
            var key = Object.keys(content)[0];
            var score = content[key].contextInfo.forwardingScore || 0;
            score += message.key.fromMe && !forceForward ? 0 : 1;
            if (key == MessageType.text)
            {
                content[MessageType.extendedText] = new Hashtable<String, dynamic>()
                {{"text", content[key]}};
                content.Remove(MessageType.text);
                key = MessageType.extendedText;
            }

            if (score > 0)
                content[key].contextInfo = (forwardingScore: score, isForwarded: true);
            else
                content[key].contextInfo = new Hashtable<String, dynamic>();
            return content;
        }

        /// <summary>
        /// Forward a message like WA
        /// </summary>
        /// <param name = "jid">
        /// the chat ID to forward to
        /// </param>
        /// <param name = "message">
        /// the message to forward
        /// </param>
        /// <param name = "forceForward">
        /// will show the message as forwarded even if it is from you
        /// </param>
        async public void forwardMessage(String jid, WAMessage message, bool forceForward = false)
        {
            var content = this.generateForwardMessageContent(message, forceForward);
            var waMessage = this.prepareMessageFromContent(jid, content, new Hashtable<String, dynamic>());
            await this.relayWAMessage(waMessage);
            return waMessage;
        }

        /// <summary>
        /// Clear the chat messages
        /// </summary>
        /// <param name = "jid">
        /// the ID of the person/group you are modifiying
        /// </param>
        /// <param name = "includeStarred">
        /// delete starred messages, default false
        /// </param>
        async public Promise<Hashtable<String, double>> modifyChat(String jid, ChatModification.clear type, bool includeStarred = false);
        /// <summary>
        /// Modify a given chat (archive, pin etc.)
        /// </summary>
        /// <param name = "jid">
        /// the ID of the person/group you are modifiying
        /// </param>
        /// <param name = "durationMs">
        /// only for muting, how long to mute the chat for
        /// </param>
        async public Promise<Hashtable<String, double>> modifyChat(String jid, dynamic type, double durationMs);
        /// <summary>
        /// Modify a given chat (archive, pin etc.)
        /// </summary>
        /// <param name = "jid">
        /// the ID of the person/group you are modifiying
        /// </param>
        async public Promise<Hashtable<String, double>> modifyChat(String jid, dynamic type);
        async public Promise<Hashtable<String, double>> modifyChat(String jid, AAA___ keyof  typeof  ChatModification  ___AAA  type, dynamic arg = null)
        {
            jid = whatsappID(jid);
            var chat = this.assertChatGet(jid);
            Record<String, String> chatAttrs = new Record<String, String>()
            {{"jid", jid}};
            if (type == ChatModification.mute && !arg)
            {
                throw new BaileysError("duration must be set to the timestamp of the time of pinning/unpinning of the chat", new
                {
                status = 400
                }

                );
            }

            double durationMs = arg as double || 0;
            bool includeStarred = arg as bool;
            WAChatIndex index;
            switch (type)
            {
                case ChatModification.pin:
                case ChatModification.mute:
                    var strStamp = (unixTimestampSeconds() + Math.floor(durationMs / 1000)).toString();
                    chatAttrs.type = type;
                    chatAttrs[type] = strStamp;
                    break;
                case ChatModification.unpin:
                case ChatModification.unmute:
                    chatAttrs.type = type.replace("un", "");
                    chatAttrs.previous = chat[type.replace("un", "")];
                    break;
                case ChatModification.clear:
                    chatAttrs.type = type;
                    chatAttrs.star = includeStarred ? "true" : "false";
                    index = await this.getChatIndex(jid);
                    chatAttrs = new Record<String, String>();
                    AAA___ delete  chatAttrs . participant  ___AAA ;
                    break;
                default:
                    chatAttrs.type = type;
                    index = await this.getChatIndex(jid);
                    chatAttrs = new Record<String, String>();
                    break;
            }

            var response = await this.setQuery(new Array<WANode>{new Array<WANode>{"chat", chatAttrs, null}}, new WATag{WAMetric.chat, WAFlag.ignore});
            if (chat && response.status == 200)
            {
                switch (type)
                {
                    case ChatModification.clear:
                        if (includeStarred)
                        {
                            chat.messages.clear();
                        }
                        else
                        {
                            chat.messages = chat.messages.filter((m) => m.starred);
                        }

                        break;
                    case ChatModification.delete:
                        this.chats.deleteById(jid);
                        this.emit("chat-update", (jid: jid, delete: "true"));
                        break;
                    default:
                        this.chats.update(jid, (chat) =>
                        {
                            if (type.includes("un"))
                            {
                                type = type.replace("un", "") as ChatModification;
                                chat.Remove(type.replace("un", ""));
                                this.emit("chat-update", (jid: jid, [type]: false));
                            }
                            else
                            {
                                chat[type] = chatAttrs[type] || "true";
                                this.emit("chat-update", (jid: jid, [type]: chat[type]));
                            }
                        }

                        );
                        break;
                }
            }

            return response;
        }

        protected async Promise<WAChatIndex> getChatIndex(String jid)
        {
            var chatAttrs = new Hashtable<String, dynamic>() as WAChatIndex;
            var { messages: [msg] } = await this.loadMessages(jid, 1);
            if (msg)
            {
                chatAttrs.index = msg.key.id;
                chatAttrs.owner = msg.key.fromMe.toString() as dynamic;
            }

            if (isGroupID(jid))
            {
                chatAttrs.participant = msg.key.fromMe ? this.user.jid : whatsappID(msg.participant || msg.key.participant);
            }

            return chatAttrs;
        }
    }
}