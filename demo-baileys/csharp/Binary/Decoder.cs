/// This file was generated by C# converter tool
/// Any changes made to this file manually will be lost next time the file is regenerated.

using System.Linq;
using TypeScript.CSharp;

namespace Bailey
{
    public class Decoder
    {
        public Decoder()
        {
            this.buffer = null;
            this.index = 0;
        }

        public Buffer buffer { get; set; }
        public int index { get; set; }

        public void checkEOS(double length)
        {
            if (this.index + length > this.buffer.length)
            {
                throw new Error("end of stream");
            }
        }

        public void next()
        {
            var value = this.buffer[this.index];
            this.index += 1;
            return value;
        }

        public void readByte()
        {
            this.checkEOS(1);
            return this.next();
        }

        public void readStringFromChars(double length)
        {
            this.checkEOS(length);
            var value = this.buffer.slice(this.index, this.index + length);
            this.index += length;
            return value.toString("utf-8");
        }

        public Buffer readBytes(double n)
        {
            this.checkEOS(n);
            var value = this.buffer.slice(this.index, this.index + n);
            this.index += n;
            return value;
        }

        public void readInt(double n, bool littleEndian = false)
        {
            this.checkEOS(n);
            var val = 0;
            for (var i = 0; i < n; i++)
            {
                var shift = littleEndian ? i : n - 1 - i;
                val |= this.next() << (shift * 8);
            }

            return val;
        }

        public void readInt20()
        {
            this.checkEOS(3);
            return ((this.next() & 15) << 16) + (this.next() << 8) + this.next();
        }

        public void unpackHex(double value)
        {
            if (value >= 0 && value < 16)
            {
                return value < 10 ? "0".charCodeAt(0) + value : "A".charCodeAt(0) + value - 10;
            }

            throw new Error("invalid hex: " + value);
        }

        public void unpackNibble(double value)
        {
            if (value >= 0 && value <= 9)
            {
                return "0".charCodeAt(0) + value;
            }

            switch (value)
            {
                case 10:
                    return "-".charCodeAt(0);
                case 11:
                    return ".".charCodeAt(0);
                case 15:
                    return "\0".charCodeAt(0);
                default:
                    throw new Error("invalid nibble: " + value);
            }
        }

        public void unpackByte(double tag, double value)
        {
            if (tag == WA.Tags.NIBBLE_8)
            {
                return this.unpackNibble(value);
            }
            else if (tag == WA.Tags.HEX_8)
            {
                return this.unpackHex(value);
            }
            else
            {
                throw new Error("unknown tag: " + tag);
            }
        }

        public void readPacked8(double tag)
        {
            var startByte = this.readByte();
            var value = "";
            for (var i = 0; i < (startByte & 127); i++)
            {
                var curByte = this.readByte();
                value += String.fromCharCode(this.unpackByte(tag, (curByte & 240) >> 4));
                value += String.fromCharCode(this.unpackByte(tag, curByte & 15));
            }

            if (startByte >> 7 != 0)
            {
                value = value.slice(0, -1);
            }

            return value;
        }

        public void readRangedVarInt(dynamic min, dynamic max, string description = "unknown")
        {
            throw new Error("WTF; should not be called");
        }

        public void isListTag(double tag)
        {
            return tag == WA.Tags.LIST_EMPTY || tag == WA.Tags.LIST_8 || tag == WA.Tags.LIST_16;
        }

        public void readListSize(double tag)
        {
            switch (tag)
            {
                case WA.Tags.LIST_EMPTY:
                    return 0;
                case WA.Tags.LIST_8:
                    return this.readByte();
                case WA.Tags.LIST_16:
                    return this.readInt(2);
                default:
                    throw new Error("invalid tag for list size: " + tag);
            }
        }

        public string readString(double tag)
        {
            if (tag >= 3 && tag <= 235)
            {
                var token = this.getToken(tag);
                return token;
            }

            switch (tag)
            {
                case WA.Tags.DICTIONARY_0:
                case WA.Tags.DICTIONARY_1:
                case WA.Tags.DICTIONARY_2:
                case WA.Tags.DICTIONARY_3:
                    return this.getTokenDouble(tag - WA.Tags.DICTIONARY_0, this.readByte());
                case WA.Tags.LIST_EMPTY:
                    return null;
                case WA.Tags.BINARY_8:
                    return this.readStringFromChars(this.readByte());
                case WA.Tags.BINARY_20:
                    return this.readStringFromChars(this.readInt20());
                case WA.Tags.BINARY_32:
                    return this.readStringFromChars(this.readInt(4));
                case WA.Tags.JID_PAIR:
                    var i = this.readString(this.readByte());
                    var j = this.readString(this.readByte());
                    if (TypeOf(i) == "string" && j)
                    {
                        return i + "@" + j;
                    }

                    throw new Error("invalid jid pair: " + i + ", " + j);
                case WA.Tags.HEX_8:
                case WA.Tags.NIBBLE_8:
                    return this.readPacked8(tag);
                default:
                    throw new Error("invalid string with tag: " + tag);
            }
        }

        public void readAttributes(double n)
        {
            if (n != 0)
            {
                WA.NodeAttributes attributes = new WA.NodeAttributes();
                for (var i = 0; i < n; i++)
                {
                    var key = this.readString(this.readByte());
                    var b = this.readByte();
                    attributes[key] = this.readString(b);
                }

                return attributes;
            }

            return null;
        }

        public void readList(double tag)
        {
            var arr = new Array(new Array(this.readListSize(tag)));
            return arr.map(() => this.readNode());
        }

        public void getToken(double index)
        {
            if (index < 3 || index >= WA.SingleByteTokens.length)
            {
                throw new Error("invalid token index: " + index);
            }

            return WA.SingleByteTokens[index];
        }

        public string getTokenDouble(dynamic index1, dynamic index2)
        {
            var n = 256 * index1 + index2;
            if (n < 0 || n > WA.DoubleByteTokens.length)
            {
                throw new Error("invalid double token index: " + n);
            }

            return WA.DoubleByteTokens[n];
        }

        public WA.Node readNode()
        {
            var listSize = this.readListSize(this.readByte());
            var descrTag = this.readByte();
            if (descrTag == WA.Tags.STREAM_END)
            {
                throw new Error("unexpected stream end");
            }

            var descr = this.readString(descrTag);
            if (listSize == 0 || !descr)
            {
                throw new Error("invalid node");
            }

            var attrs = this.readAttributes((listSize - 1) >> 1);
            WA.NodeData content = null;
            if (listSize % 2 == 0)
            {
                var tag = this.readByte();
                if (this.isListTag(tag))
                {
                    content = this.readList(tag);
                }
                else
                {
                    OrType<Buffer, string> decoded;
                    switch (tag)
                    {
                        case WA.Tags.BINARY_8:
                            decoded = this.readBytes(this.readByte());
                            break;
                        case WA.Tags.BINARY_20:
                            decoded = this.readBytes(this.readInt20());
                            break;
                        case WA.Tags.BINARY_32:
                            decoded = this.readBytes(this.readInt(4));
                            break;
                        default:
                            decoded = this.readString(tag);
                            break;
                    }

                    if (descr == "message" && Buffer.isBuffer(decoded))
                    {
                        content = WA.Message.decode(decoded);
                    }
                    else
                    {
                        content = decoded;
                    }
                }
            }

            return new WA.Node
            {
                descr,
                attrs,
                content
            };
        }

        public void read(Buffer buffer)
        {
            this.buffer = buffer;
            this.index = 0;
            return this.readNode();
        }
    }
}