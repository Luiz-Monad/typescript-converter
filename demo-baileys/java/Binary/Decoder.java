/// This file was generated by Java converter tool
/// Any changes made to this file manually will be lost next time the file is regenerated.

package demo;

public class Decoder {
    
    public /*missing*/ Decoder() {
        this.setBuffer(null);
        this.setIndex(0);
    }
    private Buffer buffer;
    
    public Buffer getBuffer() {
        return buffer;
    }
    
    public void setBuffer(Buffer value) {
        this.buffer = value;
    }
    private int index;
    
    public int getIndex() {
        return index;
    }
    
    public void setIndex(int value) {
        this.index = value;
    }
    
    public void checkEOS(double length) {
        if (this.getIndex() + length > this.getBuffer().length()) {
            throw new Error("end of stream");
        }
    }
    
    public void next() {
        final AnyXXXXXX value = this.getBuffer().get(this.getIndex());
        this.setIndex(this.getIndex() + 1);
        return value;
    }
    
    public void readByte() {
        this.checkEOS(1.0);
        return this.next();
    }
    
    public void readStringFromChars(double length) {
        this.checkEOS(length);
        final AnyXXXXXX value = StringExtension.slice(this.getBuffer(), this.getIndex(), this.getIndex() + length);
        this.setIndex(this.getIndex() + length);
        return value.toString("utf-8");
    }
    
    public Buffer readBytes(double n) {
        this.checkEOS(n);
        final AnyXXXXXX value = StringExtension.slice(this.getBuffer(), this.getIndex(), this.getIndex() + n);
        this.setIndex(this.getIndex() + n);
        return value;
    }
    
    public void readInt(double n) {
        readInt(n, false);
    }
    
    public void readInt(double n, boolean littleEndian) {
        this.checkEOS(n);
        int val = 0;
        for (int i = 0; i < n; i++) {
            final double shift = littleEndian ? i : n - 1 - i;
            val |= this.next() << (shift * 8);
        }
        return val;
    }
    
    public void readInt20() {
        this.checkEOS(3.0);
        return ((this.next() & 15) << 16) + (this.next() << 8) + this.next();
    }
    
    public void unpackHex(double value) {
        if (value >= 0 && value < 16) {
            return value < 10 ? "0".charCodeAt(0.0) + value : "A".charCodeAt(0.0) + value - 10;
        }
        throw new Error("invalid hex: " + value);
    }
    
    public void unpackNibble(double value) {
        if (value >= 0 && value <= 9) {
            return "0".charCodeAt(0.0) + value;
        }
        switch (value) {
        case 10:
            return "-".charCodeAt(0.0);
        
        case 11:
            return ".".charCodeAt(0.0);
        
        case 15:
            return "\u0000".charCodeAt(0.0);
        
        default:
            throw new Error("invalid nibble: " + value);
        
        }
    }
    
    public void unpackByte(double tag, double value) {
        if (tag == WA.getTags().getNIBBLE_8()) {
            return this.unpackNibble(value);
        } else if (tag == WA.getTags().getHEX_8()) {
            return this.unpackHex(value);
        } else {
            throw new Error("unknown tag: " + tag);
        }
    }
    
    public void readPacked8(double tag) {
        final void startByte = this.readByte();
        String value = "";
        for (int i = 0; i < (startByte & 127); i++) {
            final void curByte = this.readByte();
            value += StringExtension.fromCharCode(this.unpackByte(tag, (curByte & 240) >> 4));
            value += StringExtension.fromCharCode(this.unpackByte(tag, curByte & 15));
        }
        if (startByte >> 7 != 0) {
            value = StringExtension.slice(value, 0.0, -1.0);
        }
        return value;
    }
    
    public void readRangedVarInt(AnyXXXXXX min, AnyXXXXXX max) {
        readRangedVarInt(min, max, "unknown");
    }
    
    public void readRangedVarInt(AnyXXXXXX min, AnyXXXXXX max, String description) {
        throw new Error("WTF; should not be called");
    }
    
    public void isListTag(double tag) {
        return tag == WA.getTags().getLIST_EMPTY() || tag == WA.getTags().getLIST_8() || tag == WA.getTags().getLIST_16();
    }
    
    public void readListSize(double tag) {
        switch (tag) {
        case WA.getTags().getLIST_EMPTY():
            return 0.0;
        
        case WA.getTags().getLIST_8():
            return this.readByte();
        
        case WA.getTags().getLIST_16():
            return this.readInt(2.0);
        
        default:
            throw new Error("invalid tag for list size: " + tag);
        
        }
    }
    
    public String readString(double tag) {
        if (tag >= 3 && tag <= 235) {
            final AnyXXXXXX token = this.getToken(tag);
            return token;
        }
        switch (tag) {
        case WA.getTags().getDICTIONARY_0():
        
        case WA.getTags().getDICTIONARY_1():
        
        case WA.getTags().getDICTIONARY_2():
        
        case WA.getTags().getDICTIONARY_3():
            return this.getTokenDouble(tag - WA.getTags().getDICTIONARY_0(), this.readByte());
        
        case WA.getTags().getLIST_EMPTY():
            return null;
        
        case WA.getTags().getBINARY_8():
            return this.readStringFromChars(this.readByte());
        
        case WA.getTags().getBINARY_20():
            return this.readStringFromChars(this.readInt20());
        
        case WA.getTags().getBINARY_32():
            return this.readStringFromChars(this.readInt(4.0));
        
        case WA.getTags().getJID_PAIR():
            final String i = this.readString(this.readByte());
            final String j = this.readString(this.readByte());
            if (StringOperator.logicalCompare(typeOf(i), "===", "string") && j) {
                return i + "@" + j;
            }
            throw new Error("invalid jid pair: " + i + ", " + j);
        
        case WA.getTags().getHEX_8():
        
        case WA.getTags().getNIBBLE_8():
            return this.readPacked8(tag);
        
        default:
            throw new Error("invalid string with tag: " + tag);
        
        }
    }
    
    public void readAttributes(double n) {
        if (n != 0) {
            final WA.NodeAttributes attributes = AnyXXXXXX;
            for (int i = 0; i < n; i++) {
                final String key = this.readString(this.readByte());
                final void b = this.readByte();
                attributes.set(key, this.readString(b));
            }
            return attributes;
        }
        return null;
    }
    
    public void readList(double tag) {
        final ArrayList arr = "XXX[...new Array(this.readListSize(tag))]XXX";
        return ArrayExtension.map(arr, new IMapCallback(){
            
            public AnyXXXXXX invoke() {
                return readNode();
            }
        });
    }
    
    public void getToken(double index) {
        if (index < 3 || index >= WA.getSingleByteTokens().length()) {
            throw new Error("invalid token index: " + index);
        }
        return WA.getSingleByteTokens().get(index);
    }
    
    public String getTokenDouble(AnyXXXXXX index1, AnyXXXXXX index2) {
        final int n = 256 * index1 + index2;
        if (n < 0 || n > WA.getDoubleByteTokens().length()) {
            throw new Error("invalid double token index: " + n);
        }
        return WA.getDoubleByteTokens().get(n);
    }
    
    public WA.Node readNode() {
        final void listSize = this.readListSize(this.readByte());
        final void descrTag = this.readByte();
        if (descrTag == WA.getTags().getSTREAM_END()) {
            throw new Error("unexpected stream end");
        }
        final String descr = this.readString(descrTag);
        if (listSize == 0 || !descr) {
            throw new Error("invalid node");
        }
        final void attrs = this.readAttributes((listSize - 1) >> 1);
        WA.NodeData content = null;
        if (listSize % 2 == 0) {
            final void tag = this.readByte();
            if (this.isListTag(tag)) {
                content = this.readList(tag);
            } else {
                /*missing*/ decoded;
                switch (tag) {
                case WA.getTags().getBINARY_8():
                    decoded = this.readBytes(this.readByte());
                    break;
                
                case WA.getTags().getBINARY_20():
                    decoded = this.readBytes(this.readInt20());
                    break;
                
                case WA.getTags().getBINARY_32():
                    decoded = this.readBytes(this.readInt(4.0));
                    break;
                
                default:
                    decoded = this.readString(tag);
                    break;
                
                }
                if (StringOperator.logicalCompare(descr, "===", "message") && Buffer.isBuffer(decoded)) {
                    content = WA.getMessage().decode(decoded);
                } else {
                    content = decoded;
                }
            }
        }
        return new WA.Node(Array.asList(new AnyXXXXXX[]{descr, attrs, content}));
    }
    
    public void read(Buffer buffer) {
        this.setBuffer(buffer);
        this.setIndex(0);
        return this.readNode();
    }
}